{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useState, useEffect, useRef } from 'react';\nimport { motion, useTransform, useViewportScroll } from 'framer-motion';\nimport { wrap } from 'popmotion';\nconst gimsProps = [{\n  id: 0,\n  // needed to fix \" key for map, organize layer order \"\n  type: \"main\",\n  leftRight: 0,\n  next: 1,\n  prev: 2,\n  properties: {\n    title: \"main\",\n    size: 100,\n    posi: {\n      x: 34,\n      y: 55\n    },\n    scale: 1.8,\n    zIndex: 10\n  }\n}, {\n  id: 1,\n  type: \"next\",\n  leftRight: 1,\n  next: 3,\n  prev: 0,\n  properties: {\n    title: \"next\",\n    size: 60,\n    posi: {\n      x: 75,\n      y: 40\n    },\n    scale: 1,\n    zIndex: 10\n  }\n}, {\n  id: 2,\n  type: \"previous\",\n  leftRight: -1,\n  next: 0,\n  prev: 4,\n  properties: {\n    title: \"previous\",\n    size: 80,\n    posi: {\n      x: 15,\n      y: 12\n    },\n    scale: 0.9,\n    zIndex: 0\n  }\n}, {\n  id: 3,\n  type: \"onHold\",\n  leftRight: 1,\n  next: 4,\n  prev: 1,\n  properties: {\n    title: \"...\",\n    size: 50,\n    posi: {\n      x: 60,\n      y: 8\n    },\n    scale: 0.3,\n    zIndex: 0\n  }\n}, {\n  id: 4,\n  type: \"hidden\",\n  leftRight: -1,\n  next: 2,\n  prev: 3,\n  properties: {\n    title: \"hidden\",\n    size: 40,\n    posi: {\n      x: 40,\n      y: 9\n    },\n    scale: 0.1,\n    zIndex: 0\n  }\n}];\n\nconst getGimPropsById = gimId => {\n  return gimsProps.filter(gimProps => gimProps.id == gimId).pop() || gimsProps[0];\n};\n\nexport default function Gim({\n  data,\n  gimId,\n  direction,\n  steps,\n  nextPosition\n}) {\n  const {\n    scrollYProgress\n  } = useViewportScroll();\n  const yRange = useTransform(scrollYProgress, [0, 0.9], [0, 1]);\n  const btnRef = useRef(null);\n  const {\n    0: animationDelay,\n    1: setDelay\n  } = useState(Math.random());\n  useEffect(() => {\n    btnRef.current.setAttribute(\"disabled\", \"disabled\"); // const timer = setTimeout(() => btnRef.current.setAttribute(\"disabled\", \"disabled\") , 1300);\n    // return () => clearTimeout(timer);\n  }, []); // btnRef.current.setAttribute(\"disabled\", \"disabled\");\n\n  console.log(\"render gim : [\" + gimId + \"] random number : \" + animationDelay);\n  const currentIndex = wrap(0, gimsProps.length, steps);\n  const currentGim = getGimPropsById(gimId);\n  const prevGim = direction < 0 ? getGimPropsById(currentGim.prev) : getGimPropsById(currentGim.next);\n  const nextGim = direction < 0 ? getGimPropsById(currentGim.next) : getGimPropsById(currentGim.prev);\n  const gimvariants = {\n    enter: direction => {\n      return {\n        y: 0,\n        top: `${prevGim.properties.posi.y}%`,\n        left: `${prevGim.properties.posi.x}%`,\n        // heigth : `${currentGim.properties.size}px`,\n        // width : `${currentGim.properties.size}px`,\n        scale: prevGim.properties.scale,\n        zIndex: prevGim.properties.zIndex // backgroudColor : direction ? \"red\" : \"blue\",\n\n      };\n    },\n    standing: {\n      y: [-10, 10],\n      top: `${currentGim.properties.posi.y}%`,\n      left: `${currentGim.properties.posi.x}%`,\n      // h : `${currentGim.properties.size}px`,\n      // w : `${currentGim.properties.size}px`,\n      scale: currentGim.properties.scale,\n      zIndex: direction > 0 && gimId == 2 ? 10 : currentGim.properties.zIndex,\n      // backgroudColor : direction ? \"red\" : \"blue\",\n      transition: {\n        y: {\n          yoyo: Infinity,\n          duration: 1 // delay : animationDelay * 2\n\n        },\n        type: \"spring\",\n        duration: 1.3\n      }\n    },\n    exit: direction => {\n      return {\n        y: 0,\n        top: `${nextGim.properties.posi.y}%`,\n        left: `${nextGim.properties.posi.x}%`,\n        // heigth : `${currentGim.properties.size}px`,\n        // width : `${currentGim.properties.size}px`,\n        scale: nextGim.properties.scale,\n        zIndex: nextGim.properties.zIndex\n      };\n    }\n  };\n  const currentData = getGimCurrenData(data, gimId, steps, direction);\n  return (\n    /*#__PURE__*/\n    // <AnimatePresence initial={false} custom={direction * -1}>\n    _jsx(motion.div, {\n      ref: btnRef,\n      className: `absolute flex justify-center items-center ${\"h-36\" || \"h-4\"} ${\"w-36\" || \"w-4\"} rounded-full bg-red-400`,\n      variants: gimvariants,\n      initial: \"enter\",\n      animate: \"standing\",\n      custom: direction,\n      transition: {// type: \"spring\",\n        // duration : 4,\n      },\n      whileHover: {\n        // scale: currentGim.properties.scale * 1.2,\n        boxShadow: '0 0px 20px 8px rgba(255, 255, 255, 0.5)',\n        transition: {\n          duration: 0.3 // y: {\n          // \tyoyo : Infinity,\n          // \tduration: 1,\n          // \tdelay : animationDelay * 2\n          // },\n          // x: {\n          // \tyoyo : Infinity,\n          // \tduration: 1,\n          // },\n\n        }\n      },\n      onMouseDown: () => nextPosition(currentGim.leftRight),\n      children: /*#__PURE__*/_jsx(\"h1\", {\n        children: currentData ? currentData.current : \"\"\n      })\n    }, steps) // </AnimatePresence>\n\n  );\n}\n\nfunction fixGimsDataIndex(data, steps) {\n  let fixedIndex = steps < 0 ? (data.length + steps % data.length) % data.length : steps % data.length;\n  return fixedIndex;\n}\n\nfunction getGimCurrenData(data, gimId, moveSteps, moveDirection) {\n  switch (gimId) {\n    case 0:\n      // main gim\n      return {\n        current: data[fixGimsDataIndex(data, moveSteps + 1)],\n        next: data[fixGimsDataIndex(data, moveSteps + 2)],\n        prev: data[fixGimsDataIndex(data, moveSteps)]\n      };\n\n    case 1:\n      // next gim\n      return {\n        current: data[fixGimsDataIndex(data, moveSteps + 2)],\n        next: data[fixGimsDataIndex(data, moveSteps + 3)],\n        prev: data[fixGimsDataIndex(data, moveSteps + 1)]\n      };\n\n    case 2:\n      // prev gim\n      return {\n        current: data[fixGimsDataIndex(data, moveSteps)],\n        next: data[fixGimsDataIndex(data, moveSteps - 1)],\n        prev: data[fixGimsDataIndex(data, moveSteps + 1)]\n      };\n\n    case 3:\n      // onHold gim\n      return {\n        current: data[fixGimsDataIndex(data, moveSteps + 3)],\n        next: data[fixGimsDataIndex(data, moveSteps + 4)],\n        prev: data[fixGimsDataIndex(data, moveSteps + 2)]\n      };\n\n    case 4:\n      // hidden gim\n      let updatedIndex = moveDirection < 0 ? moveSteps : moveSteps + 3;\n      return {\n        current: data[fixGimsDataIndex(data, moveSteps + 4)],\n        next: data[fixGimsDataIndex(data, moveSteps + 5)],\n        prev: data[fixGimsDataIndex(data, updatedIndex)]\n      };\n  }\n\n  return 0;\n}","map":null,"metadata":{},"sourceType":"module"}